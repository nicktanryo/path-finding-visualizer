{"version":3,"sources":["components/Header/Title.tsx","algorithms/path/index.ts","algorithms/path/dijkstra.ts","algorithms/path/astar.ts","parameter/algorithm.ts","components/Header/AlgorithmMenu.tsx","parameter/speed.ts","components/Header/SpeedMenu.tsx","parameter/maze.ts","algorithms/maze/random.ts","components/Header/MazeMenu.tsx","components/Header/index.tsx","parameter/board.ts","utilities/mouseEvents.ts","components/Content/Board.tsx","components/Content/index.tsx","utilities/board.ts","utilities/cell.ts","components/index.tsx","App.tsx","index.tsx"],"names":["useStyles","makeStyles","logo","display","Title","classes","Avatar","alt","src","variant","className","Typography","makeCopyBoard","board","copyBoard","row","tempRow","cell","push","updateUnvisitedNeighbors","unvisitedNeighbors","column","neighbors","length","filter","isVisited","getUnvisitedNeighbors","neighborCell","distance","previous","getNeighbors","currentCell","manhattanDistance","target","Math","abs","ALGORITHM_OPTIONS","DIJKSTRA","ASTAR","ALGORITHM","startCell","targetCell","pathInOrder","unvisitedCells","cells","getBoardCells","sort","cellA","cellB","closestCell","shift","isWall","Infinity","modifiedBoard","visualizedPath","f_astar","openSet","path","a","b","neighbor","tempG","includes","AlgorithmMenu","algorithmContext","useContext","AlgorithmContext","FormControl","size","Select","value","algorithm","color","onChange","event","setAlgorithm","Object","keys","map","key","MenuItem","Capitalized","SPEED","SLOW","NORMAL","FAST","SpeedMenu","speedContext","SpeedContext","speed","setSpeed","MAZE_OPTIONS","RANDOM","MAZE","isStart","isTarget","random","MazeMenu","generateMaze","mazeContext","MazeContext","setMaze","theme","appbar","backgroundColor","title","flex","alignItems","navigator","margin","navigation","Index","visualize","resetBoard","AppBar","position","Toolbar","Grid","container","justify","item","Button","onClick","str","split","word","toUpperCase","slice","toLowerCase","join","md","ROW","COLUMN","BOARD_SIZE","CELL_SIZE","OBJECT","START","x","floor","y","TARGET","toggleWall","i","j","produce","tempBoard","wallCell","handleMouseEnter","setBoard","mouseDown","holdingPiece","setMouseDown","prevPiece","setHoldingPiece","setPrevPiece","setSTART","setTARGET","prevI","prevJ","movePiece","flexDirection","width","height","border","svg","Board","boardContext","BoardContext","SetBoard","useState","indexI","id","indexJ","params","classname","onMouseDown","handleMouseDown","onMouseUp","spot","handleMouseUp","onMouseEnter","createBoard","start","isPassed","React","createContext","undefined","maze","boardRef","useRef","animated","setAnimated","boardSize","setBoardSize","resetRefs","current","children","cname","boardContextInitValue","cleanBoard","newBoard","newCell","getBoardSize","newBoardSize","window","innerHeight","innerWidth","Start","Target","useEffect","resizeWindow","Provider","Header","pathAlgorithm","pathLength","setTimeout","finalPath","shortestPath","unshift","getShortestPath","animatePath","animateBoard","mazeOption","ref","Content","App","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.fc565a18.chunk.js","sourcesContent":["import React, { ReactElement } from \"react\";\nimport { makeStyles, Avatar, Typography } from \"@material-ui/core\";\n\nconst useStyles = makeStyles(() => ({\n    logo: {\n        display: \"inline\",\n    },\n}));\n\nfunction Title(): ReactElement {\n    const classes = useStyles();\n    return (\n        <>\n            <Avatar\n                alt=\"path-finding-visualizer\"\n                src=\"logo512.png\"\n                variant=\"square\"\n                className={classes.logo}\n            />\n\n            <Typography variant=\"h6\">Path Finding Visualizer</Typography>\n        </>\n    );\n}\n\nexport default Title;\n","import { IBoard } from \"../../utilities/board\";\nimport { ICell } from \"../../utilities/cell\";\nimport { coordinate } from \"../../parameter/board\";\n\nexport interface IAlgorithmFunction {\n    board: IBoard;\n    startCell: ICell;\n    targetCell: ICell;\n}\n\nexport interface IAlgorithmResult {\n    modifiedBoard: IBoard;\n    visualizedPath: Array<ICell>;\n}\n\nexport function makeCopyBoard(board: IBoard): IBoard {\n    const copyBoard: IBoard = [];\n    for (let row of board) {\n        const tempRow: ICell[] = [];\n        for (let cell of row) {\n            tempRow.push({\n                ...cell,\n            });\n        }\n        copyBoard.push(tempRow);\n    }\n    return copyBoard;\n}\n\nexport function getShortestPath(\n    board: IBoard,\n    TARGET: coordinate\n): Array<ICell> {\n    let copyBoard = makeCopyBoard(board);\n    let start: ICell = copyBoard[TARGET.y][TARGET.x];\n    if (!start.previous) return [];\n    start.isPassed = true;\n    let shortestPath = [start];\n    while (!!start.previous) {\n        start.previous.isPassed = true;\n        shortestPath.unshift(start.previous);\n        start = start.previous;\n    }\n    return shortestPath;\n}\n","import { ICell } from \"../../utilities/cell\";\nimport { IBoard } from \"../../utilities/board\";\nimport { IAlgorithmFunction, IAlgorithmResult, makeCopyBoard } from \".\";\n\nexport function Dijkstra({\n    board,\n    startCell,\n    targetCell,\n}: IAlgorithmFunction): IAlgorithmResult {\n    const copyBoard: IBoard = makeCopyBoard(board);\n\n    copyBoard[startCell.row][startCell.column].distance = 0;\n\n    const pathInOrder: Array<ICell> = [];\n\n    const unvisitedCells: Array<ICell> = getBoardCells(copyBoard);\n\n    while (!!unvisitedCells.length) {\n        sortCellsByDistance(unvisitedCells);\n\n        const closestCell: ICell = unvisitedCells.shift() as ICell;\n        if (closestCell.isWall) continue;\n        if (closestCell.distance === Infinity)\n            return { modifiedBoard: copyBoard, visualizedPath: pathInOrder };\n\n        closestCell.isVisited = true;\n        pathInOrder.push(closestCell);\n        if (\n            closestCell.column === targetCell.column &&\n            closestCell.row === targetCell.row\n        )\n            return { modifiedBoard: copyBoard, visualizedPath: pathInOrder };\n\n        updateUnvisitedNeighbors(closestCell, copyBoard);\n    }\n    return { modifiedBoard: copyBoard, visualizedPath: pathInOrder };\n}\n\nfunction updateUnvisitedNeighbors(cell: ICell, board: IBoard): void {\n    const unvisitedNeighbors: Array<ICell> = getUnvisitedNeighbors(cell, board);\n    for (const neighborCell of unvisitedNeighbors) {\n        neighborCell.distance = cell.distance + 1;\n        neighborCell.previous = cell;\n    }\n}\n\nfunction getUnvisitedNeighbors(cell: ICell, board: IBoard): Array<ICell> {\n    const { row, column } = cell;\n    let neighbors: Array<ICell> = [];\n\n    if (row > 0) neighbors.push(board[row - 1][column]);\n    if (row < board.length - 1) neighbors.push(board[row + 1][column]);\n    if (column > 0) neighbors.push(board[row][column - 1]);\n    if (column < board[0].length - 1) neighbors.push(board[row][column + 1]);\n\n    return neighbors.filter((cell) => !cell.isVisited);\n}\n\nfunction sortCellsByDistance(cells: Array<ICell>): void {\n    cells.sort((cellA, cellB) => cellA.distance - cellB.distance);\n}\n\nfunction getBoardCells(board: IBoard): Array<ICell> {\n    let cells: Array<ICell> = [];\n    for (const row of board) {\n        for (const cell of row) {\n            cells.push(cell);\n        }\n    }\n    return cells;\n}\n","import { IAlgorithmFunction, IAlgorithmResult, makeCopyBoard } from \".\";\nimport { ICell } from \"../../utilities/cell\";\nimport { IBoard } from \"../../utilities/board\";\n\nexport function Astar({\n    board,\n    startCell,\n    targetCell,\n}: IAlgorithmFunction): IAlgorithmResult {\n    const copyBoard = makeCopyBoard(board);\n    copyBoard[startCell.row][startCell.column].distance = 0;\n    copyBoard[startCell.row][startCell.column].f_astar = manhattanDistance(\n        startCell,\n        targetCell\n    );\n\n    let openSet: Array<ICell> = [];\n    openSet.push(copyBoard[startCell.row][startCell.column]);\n\n    let path: Array<ICell> = [];\n\n    while (!!openSet.length) {\n        sort(openSet);\n        let currentCell: ICell = openSet.shift() as ICell;\n\n        if (currentCell.isWall) continue;\n        if (currentCell.distance === Infinity)\n            return { modifiedBoard: copyBoard, visualizedPath: path };\n\n        path.push(currentCell);\n        currentCell.isVisited = true;\n        if (\n            currentCell.row === targetCell.row &&\n            currentCell.column === targetCell.column\n        )\n            return { modifiedBoard: copyBoard, visualizedPath: path };\n\n        let neighbors: Array<ICell> = getNeighbors(copyBoard, currentCell);\n        for (let neighbor of neighbors) {\n            let tempG: number = currentCell.distance + 1;\n            if (tempG < neighbor.distance) {\n                neighbor.distance = tempG;\n                neighbor.f_astar =\n                    tempG + manhattanDistance(targetCell, neighbor);\n                neighbor.previous = currentCell;\n                if (!openSet.includes(neighbor)) {\n                    openSet.push(neighbor);\n                }\n            }\n        }\n    }\n    return { modifiedBoard: copyBoard, visualizedPath: path };\n}\n\nfunction sort(set: Array<ICell>) {\n    set.sort((a: ICell, b: ICell) => (a.f_astar > b.f_astar ? 1 : -1));\n}\n\nfunction getNeighbors(board: IBoard, currentCell: ICell) {\n    const { row, column } = currentCell;\n    let neighbors = [];\n    if (row > 0) neighbors.push(board[row - 1][column]);\n    if (row < board.length - 1) neighbors.push(board[row + 1][column]);\n    if (column > 0) neighbors.push(board[row][column - 1]);\n    if (column < board[0].length - 1) neighbors.push(board[row][column + 1]);\n    return neighbors;\n}\n\nfunction manhattanDistance(target: ICell, cell: ICell) {\n    return (\n        Math.abs(target.row - cell.row) + Math.abs(target.column - cell.column)\n    );\n}\n","import { Dijkstra } from \"../algorithms/path/dijkstra\";\nimport { IDataString, IDataFunction, func } from \".\";\nimport { Astar } from \"../algorithms/path/astar\";\n\ninterface IALGORITHM_OPTIONS extends IDataString {\n    DIJKSTRA: string;\n    ASTAR: string;\n}\n\ninterface IALGORITHM extends IDataFunction {\n    DIJKSTRA: func;\n    ASTAR: func;\n}\n\nconst ALGORITHM_OPTIONS: IALGORITHM_OPTIONS = {\n    DIJKSTRA: \"DIJKSTRA\",\n    ASTAR: \"ASTAR\",\n};\nconst ALGORITHM: IALGORITHM = {\n    DIJKSTRA: Dijkstra as func,\n    ASTAR: Astar as func,\n};\n\nexport { ALGORITHM_OPTIONS, ALGORITHM };\n","import React, { ReactElement, useContext } from \"react\";\nimport { FormControl, Select, MenuItem } from \"@material-ui/core\";\nimport { AlgorithmContext, IAlgorithmContext } from \"../index\";\nimport { ALGORITHM_OPTIONS } from \"../../parameter/algorithm\";\nimport { Capitalized } from \".\";\n\nfunction AlgorithmMenu(): ReactElement {\n    const algorithmContext = useContext<IAlgorithmContext>(AlgorithmContext);\n\n    return (\n        <FormControl size=\"small\">\n            <Select\n                variant=\"outlined\"\n                value={algorithmContext.algorithm}\n                color=\"primary\"\n                onChange={(event) => {\n                    if (algorithmContext.setAlgorithm)\n                        algorithmContext.setAlgorithm(\n                            event.target.value as string\n                        );\n                }}\n            >\n                {Object.keys(ALGORITHM_OPTIONS).map((key) => {\n                    return (\n                        <MenuItem\n                            key={`algo-${key}`}\n                            value={ALGORITHM_OPTIONS[key]}\n                        >\n                            {Capitalized(ALGORITHM_OPTIONS[key])}\n                        </MenuItem>\n                    );\n                })}\n            </Select>\n        </FormControl>\n    );\n}\n\nexport default AlgorithmMenu;\n","import { IDataNumber } from \".\";\n\ninterface ISPEED extends IDataNumber {\n    SLOW: number;\n    NORMAL: number;\n    FAST: number;\n}\n\nconst SPEED: ISPEED = {\n    SLOW: 25,\n    NORMAL: 15,\n    FAST: 10,\n};\n\nexport { SPEED };\n","import React, { ReactElement, useContext } from \"react\";\nimport { SpeedContext, ISpeedContext } from \"..\";\nimport { SPEED } from \"../../parameter/speed\";\nimport { MenuItem, Select, FormControl } from \"@material-ui/core\";\n\nfunction SpeedMenu(): ReactElement {\n    const speedContext = useContext<ISpeedContext>(SpeedContext);\n    return (\n        <>\n            <FormControl size=\"small\">\n                <Select\n                    variant=\"outlined\"\n                    value={speedContext.speed}\n                    color=\"primary\"\n                    onChange={(event) => {\n                        speedContext.setSpeed &&\n                            speedContext.setSpeed(event.target.value as number);\n                    }}\n                >\n                    {Object.keys(SPEED).map((key) => {\n                        return (\n                            <MenuItem key={`algo-${key}`} value={SPEED[key]}>\n                                {key}\n                            </MenuItem>\n                        );\n                    })}\n                </Select>\n            </FormControl>\n        </>\n    );\n}\n\nexport default SpeedMenu;\n","import { IDataString } from \".\";\nimport { Random } from \"../algorithms/maze/random\";\nimport { IAlgorithmResult } from \"../algorithms/path\";\nimport { IBoard } from \"../utilities/board\";\n\ninterface IMAZE_OPTIONS extends IDataString {\n    RANDOM: string;\n}\n\nconst MAZE_OPTIONS: IMAZE_OPTIONS = {\n    RANDOM: \"RANDOM\",\n};\ninterface IDataFunctionEmpty {\n    [key: string]: (board: IBoard) => IAlgorithmResult;\n}\ninterface IMAZE extends IDataFunctionEmpty {\n    RANDOM: (board: IBoard) => IAlgorithmResult;\n}\n\nconst MAZE: IMAZE = {\n    RANDOM: Random,\n};\n\nexport { MAZE, MAZE_OPTIONS };\n","import { IAlgorithmResult, makeCopyBoard } from \"../path\";\nimport { IBoard } from \"../../utilities/board\";\nimport { ICell } from \"../../utilities/cell\";\n\nexport function Random(board: IBoard): IAlgorithmResult {\n    const copyBoard: IBoard = makeCopyBoard(board);\n    const path: Array<ICell> = [];\n    for (let row of copyBoard) {\n        for (let cell of row) {\n            if (cell.isStart || cell.isTarget) continue;\n            if (Math.random() < 0.3) {\n                cell.isWall = true;\n                path.push(cell);\n            } else {\n                cell.isWall = false;\n            }\n        }\n    }\n    return { visualizedPath: path, modifiedBoard: copyBoard };\n}\n","import React, { ReactElement, useContext } from \"react\";\nimport { FormControl, Select, MenuItem } from \"@material-ui/core\";\nimport { IMazeContext, MazeContext } from \"..\";\nimport { MAZE_OPTIONS } from \"../../parameter/maze\";\nimport { Capitalized } from \".\";\n\ninterface Props {\n    generateMaze: () => void;\n}\n\nfunction MazeMenu({ generateMaze }: Props): ReactElement {\n    const mazeContext = useContext<IMazeContext>(MazeContext);\n    return (\n        <>\n            <FormControl size=\"small\">\n                <Select\n                    variant=\"outlined\"\n                    value={\"DEFAULT\"}\n                    color=\"primary\"\n                    onChange={(event) => {\n                        if (mazeContext.setMaze)\n                            mazeContext.setMaze(\n                                MAZE_OPTIONS[event.target.value as string]\n                            );\n                        generateMaze();\n                    }}\n                >\n                    <MenuItem value=\"DEFAULT\">Generate Maze</MenuItem>\n                    {Object.keys(MAZE_OPTIONS).map((key) => {\n                        return (\n                            <MenuItem\n                                key={`algo-${key}`}\n                                value={MAZE_OPTIONS[key]}\n                            >\n                                {Capitalized(MAZE_OPTIONS[key] as string)}\n                            </MenuItem>\n                        );\n                    })}\n                </Select>\n            </FormControl>\n        </>\n    );\n}\n\nexport default MazeMenu;\n","import React, { ReactElement } from \"react\";\n\nimport {\n    AppBar,\n    Toolbar,\n    makeStyles,\n    Theme,\n    Grid,\n    Button,\n} from \"@material-ui/core\";\nimport Title from \"./Title\";\nimport AlgorithmMenu from \"./AlgorithmMenu\";\nimport SpeedMenu from \"./SpeedMenu\";\nimport MazeMenu from \"./MazeMenu\";\n\nconst useStyles = makeStyles((theme: Theme) => ({\n    appbar: {\n        backgroundColor: \"#aa96da\",\n    },\n    title: {\n        flex: 1,\n        display: \"flex\",\n        alignItems: \"center\",\n    },\n    navigator: {\n        \"& div\": {\n            margin: \"0 5px 0 5px\",\n        },\n    },\n    navigation: {\n        color: \"white\",\n    },\n}));\n\ninterface Props {\n    visualize: () => void;\n    resetBoard: () => void;\n    generateMaze: () => void;\n}\n\nfunction Index({ visualize, resetBoard, generateMaze }: Props): ReactElement {\n    const classes = useStyles();\n\n    return (\n        <AppBar position=\"static\" className={classes.appbar}>\n            <Toolbar>\n                <Grid container justify=\"space-between\">\n                    <Grid item className={classes.title}>\n                        <Title />\n                    </Grid>\n\n                    <Grid item className={classes.navigator}>\n                        <MazeMenu generateMaze={generateMaze} />\n                        <AlgorithmMenu />\n                        <SpeedMenu />\n                        <Button\n                            color=\"primary\"\n                            className={classes.navigation}\n                            onClick={visualize}\n                        >\n                            VISUALIZE\n                        </Button>\n                        <Button\n                            color=\"primary\"\n                            className={classes.navigation}\n                            onClick={resetBoard}\n                        >\n                            RESET\n                        </Button>\n                    </Grid>\n                </Grid>\n            </Toolbar>\n        </AppBar>\n    );\n}\n\nexport default Index;\n\nexport function Capitalized(str: string): string {\n    return str\n        .split(\" \")\n        .map((word) => word[0].toUpperCase() + word.slice(1).toLowerCase())\n        .join(\" \");\n}\n","export interface IBoardSize {\n    ROW: number;\n    COLUMN: number;\n}\n\n// const lg = {\n//     ROW: 30,\n//     COLUMN: 65,\n// };\n\nconst md = {\n    ROW: 20,\n    COLUMN: 37,\n};\n\nconst BOARD_SIZE: IBoardSize = md;\n\nconst CELL_SIZE: number = BOARD_SIZE === md ? 30 : 20;\n\nconst OBJECT: { START: string; TARGET: string } = {\n    START: \"isStart\",\n    TARGET: \"isTarget\",\n};\n\nexport interface coordinate {\n    x: number;\n    y: number;\n}\nconst START: coordinate = {\n    x: Math.floor(BOARD_SIZE.COLUMN / 3),\n    y: Math.floor(BOARD_SIZE.ROW / 2),\n};\n\nconst TARGET: coordinate = {\n    x: BOARD_SIZE.COLUMN - START.x,\n    y: Math.floor(BOARD_SIZE.ROW / 2),\n};\n\nexport { BOARD_SIZE, CELL_SIZE, START, TARGET, OBJECT };\n","import produce from \"immer\";\nimport React from \"react\";\nimport { IBoard } from \"./board\";\nimport { OBJECT, coordinate } from \"../parameter/board\";\n\nexport interface mouseEvent {\n    i: number;\n    j: number;\n    board: IBoard;\n    setBoard: React.Dispatch<React.SetStateAction<IBoard>>;\n    mouseDown: boolean;\n    setMouseDown: React.Dispatch<React.SetStateAction<boolean>>;\n    holdingPiece: string | null;\n    setHoldingPiece: React.Dispatch<React.SetStateAction<string | null>>;\n    prevPiece: Array<number>;\n    setPrevPiece: React.Dispatch<React.SetStateAction<Array<number>>>;\n    setSTART?: React.Dispatch<React.SetStateAction<coordinate>>;\n    setTARGET?: React.Dispatch<React.SetStateAction<coordinate>>;\n}\n\nfunction toggleWall(board: IBoard, i: number, j: number): IBoard {\n    return produce(board, (tempBoard) => {\n        let cell = tempBoard[i][j];\n        let wallCell = {\n            ...cell,\n            isWall: !cell.isWall,\n        };\n        tempBoard[i][j] = wallCell;\n        return tempBoard;\n    });\n}\nfunction movePiece(\n    board: IBoard,\n    i: number,\n    j: number,\n    prevI: number,\n    prevJ: number,\n    holdingPiece: string\n): IBoard {\n    return produce(board, (tempBoard) => {\n        tempBoard[prevI][prevJ] = {\n            ...tempBoard[prevI][prevJ],\n            isStart: false,\n            isTarget: false,\n        };\n        tempBoard[i][j] = { ...tempBoard[i][j], [holdingPiece]: true };\n        return tempBoard;\n    });\n}\n\nexport function handleMouseDown({\n    i,\n    j,\n    board,\n    setBoard,\n    mouseDown,\n    setMouseDown,\n    holdingPiece,\n    setHoldingPiece,\n    prevPiece,\n    setPrevPiece,\n    setSTART,\n    setTARGET,\n}: mouseEvent): void {\n    setMouseDown(true);\n    const { isStart, isTarget } = board[i][j];\n    if (isStart || isTarget) {\n        setHoldingPiece(isStart ? OBJECT.START : OBJECT.TARGET);\n        setPrevPiece([i, j]);\n    } else {\n        setBoard(toggleWall(board, i, j));\n    }\n}\n\nexport function handleMouseEnter({\n    i,\n    j,\n    board,\n    setBoard,\n    mouseDown,\n    setMouseDown,\n    holdingPiece,\n    setHoldingPiece,\n    prevPiece,\n    setPrevPiece,\n    setSTART,\n    setTARGET,\n}: mouseEvent) {\n    if (!mouseDown) return;\n    if (holdingPiece) {\n        if (\n            !board[i][j].isWall &&\n            ((holdingPiece === OBJECT.START && !board[i][j].isTarget) ||\n                (holdingPiece === OBJECT.TARGET && !board[i][j].isStart))\n        ) {\n            setBoard(\n                movePiece(board, i, j, prevPiece[0], prevPiece[1], holdingPiece)\n            );\n            setPrevPiece([i, j]);\n        }\n    } else {\n        if (board[i][j].isStart || board[i][j].isTarget) return;\n        setBoard(toggleWall(board, i, j));\n    }\n}\n\nexport function handleMouseUp({\n    i,\n    j,\n    board,\n    setBoard,\n    mouseDown,\n    setMouseDown,\n    holdingPiece,\n    setHoldingPiece,\n    prevPiece,\n    setPrevPiece,\n    setSTART,\n    setTARGET,\n}: mouseEvent): void {\n    setMouseDown(false);\n    if (holdingPiece) {\n        const spot: coordinate = {\n            x: j,\n            y: i,\n        };\n        if (holdingPiece === OBJECT.START) {\n            if (setSTART) setSTART(spot);\n        } else if (holdingPiece === OBJECT.TARGET) {\n            if (setTARGET) setTARGET(spot);\n        }\n        setHoldingPiece(null);\n        setPrevPiece([-1, -1]);\n    }\n}\n","import React, { ReactElement, useState, useContext } from \"react\";\nimport classname from \"classname\";\nimport \"./Board.css\";\n\n// MUI --------------------------------------------------------------\nimport { Theme, makeStyles } from \"@material-ui/core\";\nimport ControlCameraIcon from \"@material-ui/icons/ControlCamera\";\nimport KeyboardArrowRightIcon from \"@material-ui/icons/KeyboardArrowRight\";\n\n// parameters -------------------------------------------------------\nimport { CELL_SIZE } from \"../../parameter/board\";\n\n// utilities --------------------------------------------------------\nimport { IBoard } from \"../../utilities/board\";\nimport { ICell } from \"../../utilities/cell\";\nimport {\n    mouseEvent,\n    handleMouseDown,\n    handleMouseEnter,\n    handleMouseUp,\n} from \"../../utilities/mouseEvents\";\n\n//context -----------------------------------------------------------\nimport { BoardContext, IBoardContext } from \"../index\";\n\nconst useStyles = makeStyles((theme: Theme) => ({\n    row: {\n        display: \"flex\",\n        flexDirection: \"row\",\n        alignItems: \"center\",\n    },\n    cell: {\n        width: `${CELL_SIZE}px`,\n        height: `${CELL_SIZE}px`,\n        border: \".5px solid lightblue\",\n    },\n    svg: {\n        width: \"100%\",\n        height: \"100%\",\n    },\n}));\n\nfunction Board(): ReactElement {\n    const classes = useStyles();\n\n    const boardContext = useContext<IBoardContext>(BoardContext);\n    const { board, setBoard: SetBoard, setSTART, setTARGET } = boardContext;\n\n    const [mouseDown, setMouseDown] = useState<boolean>(false);\n    const [holdingPiece, setHoldingPiece] = useState<string | null>(null);\n    const [prevPiece, setPrevPiece] = useState<Array<number>>([-1, -1]);\n\n    return (\n        <>\n            {board.map((row: Array<ICell>, indexI: number) => {\n                return (\n                    <div\n                        key={`row-${indexI}`}\n                        id={`row-${indexI}`}\n                        className={classes.row}\n                    >\n                        {row.map((cell: ICell, indexJ: number) => {\n                            let setBoard = SetBoard as React.Dispatch<\n                                React.SetStateAction<IBoard>\n                            >;\n                            let params: mouseEvent = {\n                                i: indexI,\n                                j: indexJ,\n                                board,\n                                setBoard,\n                                mouseDown,\n                                setMouseDown,\n                                holdingPiece,\n                                setHoldingPiece,\n                                prevPiece,\n                                setPrevPiece,\n                                setSTART,\n                                setTARGET,\n                            };\n                            return (\n                                <div\n                                    key={`cell-${indexI}-${indexJ}`}\n                                    id={`cell-${indexI}-${indexJ}`}\n                                    className={classname(classes.cell)}\n                                    onMouseDown={() => handleMouseDown(params)}\n                                    onMouseUp={() => handleMouseUp(params)}\n                                    onMouseEnter={() =>\n                                        handleMouseEnter(params)\n                                    }\n                                >\n                                    <div\n                                        className={\n                                            cell.isWall\n                                                ? \"background wall\"\n                                                : \"background\"\n                                        }\n                                    >\n                                        {cell.isStart ? (\n                                            <KeyboardArrowRightIcon\n                                                className={classes.svg}\n                                            />\n                                        ) : cell.isTarget ? (\n                                            <ControlCameraIcon\n                                                className={classes.svg}\n                                            />\n                                        ) : null}\n                                    </div>\n                                </div>\n                            );\n                        })}\n                    </div>\n                );\n            })}\n        </>\n    );\n}\n\nexport default Board;\n","import React, { ReactElement } from \"react\";\nimport Board from \"./Board\";\n\nfunction Index(): ReactElement {\n    return <Board />;\n}\n\nexport default Index;\n","import newCell, { ICell } from \"./cell\";\n\ninterface coordinate {\n    x: number;\n    y: number;\n}\n\ninterface boardSize {\n    ROW: number;\n    COLUMN: number;\n}\n\nexport type IBoard = Array<Array<ICell>>;\n\nexport function createBoard(\n    BOARD_SIZE: boardSize,\n    START: coordinate,\n    TARGET: coordinate\n): IBoard {\n    const tempBoard: Array<Array<ICell>> = [];\n    for (let i = 0; i < BOARD_SIZE.ROW; i++) {\n        const tempRow: Array<ICell> = [];\n        for (let j = 0; j < BOARD_SIZE.COLUMN; j++) {\n            tempRow.push(\n                newCell(\n                    i,\n                    j,\n                    i === START.y && j === START.x,\n                    i === TARGET.y && j === TARGET.x\n                )\n            );\n        }\n        tempBoard.push(tempRow);\n    }\n    return tempBoard;\n}\n","export default function newCell(\n    row: number,\n    column: number,\n    start: boolean,\n    target: boolean\n): ICell {\n    return {\n        isStart: start,\n        isTarget: target,\n        row,\n        column,\n        isVisited: false,\n        isWall: false,\n        isPassed: false,\n        distance: Infinity,\n        f_astar: Infinity,\n        previous: null,\n    };\n}\n\nexport interface ICell {\n    isStart: boolean;\n    isTarget: boolean;\n    isVisited: boolean;\n    isWall: boolean;\n    isPassed: boolean;\n    row: number;\n    column: number;\n    distance: number;\n    f_astar: number;\n    previous: ICell | null;\n}\n","import React, { ReactElement, useState, useRef, useEffect } from \"react\";\n\nimport Header from \"./Header\";\nimport Content from \"./Content\";\n\nimport { SPEED } from \"../parameter/speed\";\nimport { ALGORITHM, ALGORITHM_OPTIONS } from \"../parameter/algorithm\";\nimport { IBoard, createBoard } from \"../utilities/board\";\nimport {\n    BOARD_SIZE,\n    coordinate,\n    START as start,\n    TARGET as target,\n    CELL_SIZE,\n    IBoardSize,\n} from \"../parameter/board\";\nimport {\n    IAlgorithmFunction,\n    getShortestPath,\n    IAlgorithmResult,\n    makeCopyBoard,\n} from \"../algorithms/path\";\nimport { ICell } from \"../utilities/cell\";\nimport { makeStyles, Theme } from \"@material-ui/core\";\nimport { MAZE_OPTIONS, MAZE } from \"../parameter/maze\";\n\nconst useStyles = makeStyles((theme: Theme) => ({\n    board: {\n        display: \"flex\",\n        flexDirection: \"column\",\n        alignItems: \"center\",\n    },\n}));\n\n// context -----------------------------------------------------------------\nexport interface ISpeedContext {\n    speed: number;\n    setSpeed: React.Dispatch<React.SetStateAction<number>> | undefined;\n}\nexport const SpeedContext = React.createContext<ISpeedContext>({\n    speed: SPEED.NORMAL,\n    setSpeed: undefined,\n});\n\nexport interface IMazeContext {\n    maze: string;\n    setMaze: React.Dispatch<React.SetStateAction<string>> | undefined;\n}\nexport const MazeContext = React.createContext<IMazeContext>({\n    maze: MAZE_OPTIONS.RANDOM,\n    setMaze: undefined,\n});\n\nexport interface IAlgorithmContext {\n    algorithm: string;\n    setAlgorithm: React.Dispatch<React.SetStateAction<string>> | undefined;\n}\nexport const AlgorithmContext = React.createContext<IAlgorithmContext>({\n    algorithm: ALGORITHM_OPTIONS.DIJKSTRA,\n    setAlgorithm: undefined,\n});\n\nexport interface IBoardContext {\n    board: IBoard;\n    setBoard: React.Dispatch<React.SetStateAction<IBoard>> | undefined;\n    START: coordinate;\n    setSTART: React.Dispatch<React.SetStateAction<coordinate>> | undefined;\n    TARGET: coordinate;\n    setTARGET: React.Dispatch<React.SetStateAction<coordinate>> | undefined;\n}\nexport const BoardContext = React.createContext<IBoardContext>({\n    board: createBoard(BOARD_SIZE, start, target),\n    setBoard: undefined,\n    START: start,\n    setSTART: undefined,\n    TARGET: target,\n    setTARGET: undefined,\n});\n\n// -------------------------------------------------------------------------\n\nfunction Index(): ReactElement {\n    const classes = useStyles();\n    const boardRef = useRef(null);\n\n    // visualization option\n    const [speed, setSpeed] = useState<number>(SPEED.NORMAL);\n    const [maze, setMaze] = useState<string>(MAZE_OPTIONS.RANDOM);\n    const [algorithm, setAlgorithm] = useState<string>(\n        ALGORITHM_OPTIONS.DIJKSTRA\n    );\n\n    // board properties\n    const [animated, setAnimated] = useState<boolean>(false);\n    const [START, setSTART] = useState<coordinate>(start);\n    const [TARGET, setTARGET] = useState<coordinate>(target);\n    const [boardSize, setBoardSize] = useState<IBoardSize>(BOARD_SIZE);\n    const [board, setBoard] = useState<IBoard>(\n        createBoard(BOARD_SIZE, start, target)\n    );\n\n    function resetRefs() {\n        for (let row = 0; row < boardSize.ROW; row++) {\n            for (let column = 0; column < boardSize.COLUMN; column++) {\n                (boardRef as any).current.children[row].children[\n                    column\n                ].children[0].className = (boardRef as any).current.children[\n                    row\n                ].children[column].children[0].className\n                    .split(\" \")\n                    .filter(\n                        (cname: string) =>\n                            cname !== \"visited\" && cname !== \"passed\"\n                    )\n                    .join(\" \");\n            }\n        }\n    }\n\n    function resetBoard() {\n        const { newBoardSize, Start, Target } = getBoardSize();\n        resetRefs();\n        setSTART(Start);\n        setTARGET(Target);\n        setAnimated(false);\n        setBoard(createBoard(newBoardSize, Start, Target));\n    }\n\n    const boardContextInitValue = {\n        board,\n        setBoard,\n        START,\n        setSTART,\n        TARGET,\n        setTARGET,\n    };\n\n    // algorithm visualization process --------------\n    function cleanBoard(): IBoard {\n        resetRefs();\n        const copyBoard = makeCopyBoard(board);\n        const newBoard: IBoard = [];\n        for (let row of copyBoard) {\n            let tempRow: Array<ICell> = [];\n            for (let cell of row) {\n                let newCell: ICell = {\n                    ...cell,\n                    isPassed: false,\n                    isVisited: false,\n                    distance: Infinity,\n                    previous: null,\n                    f_astar: Infinity,\n                };\n                tempRow.push(newCell);\n            }\n            newBoard.push(tempRow);\n        }\n        return newBoard;\n    }\n\n    function analyzeBoard(): void {\n        const newBoard = cleanBoard();\n        setAnimated(true);\n        const pathAlgorithm = ALGORITHM[algorithm];\n        const value: IAlgorithmFunction = {\n            board: newBoard,\n            startCell: board[START.y][START.x],\n            targetCell: board[TARGET.y][TARGET.x],\n        };\n        let { modifiedBoard, visualizedPath }: IAlgorithmResult = pathAlgorithm(\n            value\n        );\n        setBoard(modifiedBoard);\n        animateBoard(visualizedPath, modifiedBoard);\n    }\n\n    function animateBoard(path: Array<ICell>, modifiedBoard: IBoard): void {\n        const pathLength = path.length;\n        for (let i = 0; i < pathLength; i++) {\n            const { row, column } = path[i];\n            setTimeout(() => {\n                (boardRef as any).current.children[row].children[\n                    column\n                ].children[0].className += \" visited\";\n            }, speed * i);\n        }\n        const finalPath = getShortestPath(modifiedBoard, TARGET);\n        setTimeout(() => {\n            animatePath(finalPath);\n        }, speed * pathLength);\n    }\n\n    function animatePath(path: Array<ICell>): void {\n        let pathLength = path.length;\n        for (let i = 0; i < pathLength; i++) {\n            const { row, column } = path[i];\n            setTimeout(() => {\n                (boardRef as any).current.children[row].children[\n                    column\n                ].children[0].className = (boardRef as any).current.children[\n                    row\n                ].children[column].children[0].className\n                    .split(\" \")\n                    .map((cname: string) =>\n                        cname === \"visited\" ? \"passed\" : cname\n                    )\n                    .join(\" \");\n            }, 2 * speed * i);\n        }\n    }\n\n    // maze generation visualization ----------------\n    function generateMaze() {\n        if (animated) cleanBoard();\n        const mazeOption = MAZE[maze];\n        const { modifiedBoard } = mazeOption(board);\n        setBoard(modifiedBoard);\n    }\n\n    // detectinng window size\n    function getBoardSize(): {\n        newBoardSize: IBoardSize;\n        Start: coordinate;\n        Target: coordinate;\n    } {\n        const newBoardSize: IBoardSize = {\n            ROW: Math.floor((window.innerHeight - 130) / (CELL_SIZE + 1)),\n            COLUMN: Math.floor(window.innerWidth / (CELL_SIZE + 2)),\n        };\n\n        const Start: coordinate = {\n            x: Math.floor(newBoardSize.COLUMN / 3),\n            y: Math.floor(newBoardSize.ROW / 2),\n        };\n        const Target: coordinate = {\n            x: newBoardSize.COLUMN - Start.x,\n            y: Math.floor(newBoardSize.ROW / 2),\n        };\n        return { newBoardSize, Start, Target };\n    }\n\n    useEffect(() => {\n        function resizeWindow(): void {\n            const { newBoardSize, Start, Target } = getBoardSize();\n            setBoardSize(newBoardSize);\n            setSTART(Start);\n            setTARGET(Target);\n            setBoard(createBoard(newBoardSize, Start, Target));\n        }\n        resizeWindow();\n    }, []);\n\n    return (\n        <SpeedContext.Provider value={{ speed, setSpeed }}>\n            <AlgorithmContext.Provider value={{ algorithm, setAlgorithm }}>\n                <BoardContext.Provider value={boardContextInitValue}>\n                    <div>\n                        <MazeContext.Provider value={{ maze, setMaze }}>\n                            <Header\n                                visualize={analyzeBoard}\n                                resetBoard={resetBoard}\n                                generateMaze={generateMaze}\n                            />\n                        </MazeContext.Provider>\n                        <div ref={boardRef} className={classes.board}>\n                            <Content />\n                        </div>\n                    </div>\n                </BoardContext.Provider>\n            </AlgorithmContext.Provider>\n        </SpeedContext.Provider>\n    );\n}\n\nexport default Index;\n","import React from \"react\";\nimport \"./App.css\";\n\nimport PathFinding from \"./components\";\n\nfunction App() {\n    return (\n        <div className=\"App\">\n            <PathFinding />\n        </div>\n    );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}